// Code generated by SQLBoiler 3.6.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// WorkHolderRelation is an object representing the database table.
type WorkHolderRelation struct {
	WorkID       string      `boil:"work_id" json:"work_id" toml:"work_id" yaml:"work_id"`
	WorkHolderID string      `boil:"work_holder_id" json:"work_holder_id" toml:"work_holder_id" yaml:"work_holder_id"`
	CreateUser   null.String `boil:"create_user" json:"create_user,omitempty" toml:"create_user" yaml:"create_user,omitempty"`
	CreatedAt    time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdateUser   null.String `boil:"update_user" json:"update_user,omitempty" toml:"update_user" yaml:"update_user,omitempty"`
	UpdatedAt    null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt    null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *workHolderRelationR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L workHolderRelationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var WorkHolderRelationColumns = struct {
	WorkID       string
	WorkHolderID string
	CreateUser   string
	CreatedAt    string
	UpdateUser   string
	UpdatedAt    string
	DeletedAt    string
}{
	WorkID:       "work_id",
	WorkHolderID: "work_holder_id",
	CreateUser:   "create_user",
	CreatedAt:    "created_at",
	UpdateUser:   "update_user",
	UpdatedAt:    "updated_at",
	DeletedAt:    "deleted_at",
}

// Generated where

var WorkHolderRelationWhere = struct {
	WorkID       whereHelperstring
	WorkHolderID whereHelperstring
	CreateUser   whereHelpernull_String
	CreatedAt    whereHelpertime_Time
	UpdateUser   whereHelpernull_String
	UpdatedAt    whereHelpernull_Time
	DeletedAt    whereHelpernull_Time
}{
	WorkID:       whereHelperstring{field: "\"work_holder_relation\".\"work_id\""},
	WorkHolderID: whereHelperstring{field: "\"work_holder_relation\".\"work_holder_id\""},
	CreateUser:   whereHelpernull_String{field: "\"work_holder_relation\".\"create_user\""},
	CreatedAt:    whereHelpertime_Time{field: "\"work_holder_relation\".\"created_at\""},
	UpdateUser:   whereHelpernull_String{field: "\"work_holder_relation\".\"update_user\""},
	UpdatedAt:    whereHelpernull_Time{field: "\"work_holder_relation\".\"updated_at\""},
	DeletedAt:    whereHelpernull_Time{field: "\"work_holder_relation\".\"deleted_at\""},
}

// WorkHolderRelationRels is where relationship names are stored.
var WorkHolderRelationRels = struct {
}{}

// workHolderRelationR is where relationships are stored.
type workHolderRelationR struct {
}

// NewStruct creates a new relationship struct
func (*workHolderRelationR) NewStruct() *workHolderRelationR {
	return &workHolderRelationR{}
}

// workHolderRelationL is where Load methods for each relationship are stored.
type workHolderRelationL struct{}

var (
	workHolderRelationAllColumns            = []string{"work_id", "work_holder_id", "create_user", "created_at", "update_user", "updated_at", "deleted_at"}
	workHolderRelationColumnsWithoutDefault = []string{"work_id", "work_holder_id", "updated_at", "deleted_at"}
	workHolderRelationColumnsWithDefault    = []string{"create_user", "created_at", "update_user"}
	workHolderRelationPrimaryKeyColumns     = []string{"work_id", "work_holder_id"}
)

type (
	// WorkHolderRelationSlice is an alias for a slice of pointers to WorkHolderRelation.
	// This should generally be used opposed to []WorkHolderRelation.
	WorkHolderRelationSlice []*WorkHolderRelation
	// WorkHolderRelationHook is the signature for custom WorkHolderRelation hook methods
	WorkHolderRelationHook func(context.Context, boil.ContextExecutor, *WorkHolderRelation) error

	workHolderRelationQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	workHolderRelationType                 = reflect.TypeOf(&WorkHolderRelation{})
	workHolderRelationMapping              = queries.MakeStructMapping(workHolderRelationType)
	workHolderRelationPrimaryKeyMapping, _ = queries.BindMapping(workHolderRelationType, workHolderRelationMapping, workHolderRelationPrimaryKeyColumns)
	workHolderRelationInsertCacheMut       sync.RWMutex
	workHolderRelationInsertCache          = make(map[string]insertCache)
	workHolderRelationUpdateCacheMut       sync.RWMutex
	workHolderRelationUpdateCache          = make(map[string]updateCache)
	workHolderRelationUpsertCacheMut       sync.RWMutex
	workHolderRelationUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var workHolderRelationBeforeInsertHooks []WorkHolderRelationHook
var workHolderRelationBeforeUpdateHooks []WorkHolderRelationHook
var workHolderRelationBeforeDeleteHooks []WorkHolderRelationHook
var workHolderRelationBeforeUpsertHooks []WorkHolderRelationHook

var workHolderRelationAfterInsertHooks []WorkHolderRelationHook
var workHolderRelationAfterSelectHooks []WorkHolderRelationHook
var workHolderRelationAfterUpdateHooks []WorkHolderRelationHook
var workHolderRelationAfterDeleteHooks []WorkHolderRelationHook
var workHolderRelationAfterUpsertHooks []WorkHolderRelationHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *WorkHolderRelation) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *WorkHolderRelation) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *WorkHolderRelation) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *WorkHolderRelation) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *WorkHolderRelation) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *WorkHolderRelation) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *WorkHolderRelation) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *WorkHolderRelation) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *WorkHolderRelation) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range workHolderRelationAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddWorkHolderRelationHook registers your hook function for all future operations.
func AddWorkHolderRelationHook(hookPoint boil.HookPoint, workHolderRelationHook WorkHolderRelationHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		workHolderRelationBeforeInsertHooks = append(workHolderRelationBeforeInsertHooks, workHolderRelationHook)
	case boil.BeforeUpdateHook:
		workHolderRelationBeforeUpdateHooks = append(workHolderRelationBeforeUpdateHooks, workHolderRelationHook)
	case boil.BeforeDeleteHook:
		workHolderRelationBeforeDeleteHooks = append(workHolderRelationBeforeDeleteHooks, workHolderRelationHook)
	case boil.BeforeUpsertHook:
		workHolderRelationBeforeUpsertHooks = append(workHolderRelationBeforeUpsertHooks, workHolderRelationHook)
	case boil.AfterInsertHook:
		workHolderRelationAfterInsertHooks = append(workHolderRelationAfterInsertHooks, workHolderRelationHook)
	case boil.AfterSelectHook:
		workHolderRelationAfterSelectHooks = append(workHolderRelationAfterSelectHooks, workHolderRelationHook)
	case boil.AfterUpdateHook:
		workHolderRelationAfterUpdateHooks = append(workHolderRelationAfterUpdateHooks, workHolderRelationHook)
	case boil.AfterDeleteHook:
		workHolderRelationAfterDeleteHooks = append(workHolderRelationAfterDeleteHooks, workHolderRelationHook)
	case boil.AfterUpsertHook:
		workHolderRelationAfterUpsertHooks = append(workHolderRelationAfterUpsertHooks, workHolderRelationHook)
	}
}

// One returns a single workHolderRelation record from the query.
func (q workHolderRelationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*WorkHolderRelation, error) {
	o := &WorkHolderRelation{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for work_holder_relation")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all WorkHolderRelation records from the query.
func (q workHolderRelationQuery) All(ctx context.Context, exec boil.ContextExecutor) (WorkHolderRelationSlice, error) {
	var o []*WorkHolderRelation

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to WorkHolderRelation slice")
	}

	if len(workHolderRelationAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all WorkHolderRelation records in the query.
func (q workHolderRelationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count work_holder_relation rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q workHolderRelationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if work_holder_relation exists")
	}

	return count > 0, nil
}

// WorkHolderRelations retrieves all the records using an executor.
func WorkHolderRelations(mods ...qm.QueryMod) workHolderRelationQuery {
	mods = append(mods, qm.From("\"work_holder_relation\""))
	return workHolderRelationQuery{NewQuery(mods...)}
}

// FindWorkHolderRelation retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindWorkHolderRelation(ctx context.Context, exec boil.ContextExecutor, workID string, workHolderID string, selectCols ...string) (*WorkHolderRelation, error) {
	workHolderRelationObj := &WorkHolderRelation{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"work_holder_relation\" where \"work_id\"=$1 AND \"work_holder_id\"=$2", sel,
	)

	q := queries.Raw(query, workID, workHolderID)

	err := q.Bind(ctx, exec, workHolderRelationObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from work_holder_relation")
	}

	return workHolderRelationObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *WorkHolderRelation) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no work_holder_relation provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(workHolderRelationColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	workHolderRelationInsertCacheMut.RLock()
	cache, cached := workHolderRelationInsertCache[key]
	workHolderRelationInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			workHolderRelationAllColumns,
			workHolderRelationColumnsWithDefault,
			workHolderRelationColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(workHolderRelationType, workHolderRelationMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(workHolderRelationType, workHolderRelationMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"work_holder_relation\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"work_holder_relation\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into work_holder_relation")
	}

	if !cached {
		workHolderRelationInsertCacheMut.Lock()
		workHolderRelationInsertCache[key] = cache
		workHolderRelationInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the WorkHolderRelation.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *WorkHolderRelation) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	workHolderRelationUpdateCacheMut.RLock()
	cache, cached := workHolderRelationUpdateCache[key]
	workHolderRelationUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			workHolderRelationAllColumns,
			workHolderRelationPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update work_holder_relation, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"work_holder_relation\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, workHolderRelationPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(workHolderRelationType, workHolderRelationMapping, append(wl, workHolderRelationPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update work_holder_relation row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for work_holder_relation")
	}

	if !cached {
		workHolderRelationUpdateCacheMut.Lock()
		workHolderRelationUpdateCache[key] = cache
		workHolderRelationUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q workHolderRelationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for work_holder_relation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for work_holder_relation")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o WorkHolderRelationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), workHolderRelationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"work_holder_relation\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, workHolderRelationPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in workHolderRelation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all workHolderRelation")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *WorkHolderRelation) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no work_holder_relation provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(workHolderRelationColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	workHolderRelationUpsertCacheMut.RLock()
	cache, cached := workHolderRelationUpsertCache[key]
	workHolderRelationUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			workHolderRelationAllColumns,
			workHolderRelationColumnsWithDefault,
			workHolderRelationColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			workHolderRelationAllColumns,
			workHolderRelationPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert work_holder_relation, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(workHolderRelationPrimaryKeyColumns))
			copy(conflict, workHolderRelationPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"work_holder_relation\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(workHolderRelationType, workHolderRelationMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(workHolderRelationType, workHolderRelationMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert work_holder_relation")
	}

	if !cached {
		workHolderRelationUpsertCacheMut.Lock()
		workHolderRelationUpsertCache[key] = cache
		workHolderRelationUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single WorkHolderRelation record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *WorkHolderRelation) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no WorkHolderRelation provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), workHolderRelationPrimaryKeyMapping)
	sql := "DELETE FROM \"work_holder_relation\" WHERE \"work_id\"=$1 AND \"work_holder_id\"=$2"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from work_holder_relation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for work_holder_relation")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q workHolderRelationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no workHolderRelationQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from work_holder_relation")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for work_holder_relation")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o WorkHolderRelationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(workHolderRelationBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), workHolderRelationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"work_holder_relation\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, workHolderRelationPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from workHolderRelation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for work_holder_relation")
	}

	if len(workHolderRelationAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *WorkHolderRelation) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindWorkHolderRelation(ctx, exec, o.WorkID, o.WorkHolderID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *WorkHolderRelationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := WorkHolderRelationSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), workHolderRelationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"work_holder_relation\".* FROM \"work_holder_relation\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, workHolderRelationPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in WorkHolderRelationSlice")
	}

	*o = slice

	return nil
}

// WorkHolderRelationExists checks if the WorkHolderRelation row exists.
func WorkHolderRelationExists(ctx context.Context, exec boil.ContextExecutor, workID string, workHolderID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"work_holder_relation\" where \"work_id\"=$1 AND \"work_holder_id\"=$2 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, workID, workHolderID)
	}
	row := exec.QueryRowContext(ctx, sql, workID, workHolderID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if work_holder_relation exists")
	}

	return exists, nil
}
